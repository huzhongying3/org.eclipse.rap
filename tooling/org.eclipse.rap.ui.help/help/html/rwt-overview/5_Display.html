<h1>5 Display</h1>
<a name="Display"></a><h2>Display</h2>
<p>The display represents the client side browser window. All <a href="11_Controls%2C_Composites%2C_Groups%2C_and_Shells.html#Class_Shell" title="11 Controls, Composites, Groups, and Shells">shells</a> that belong to a display
reside in one browser window.
</p><p>The display creation in RWT is slightly different than in SWT. Instead of a main method RWT provides the IEntryPoint Interface in its createUI method. In this method you need to implement the creation of the display and the initial set of widgets to be displayed.
</p><p><code>
</p>
<pre> public class Example implements IEntryPoint {
   public Display createUI() {
     Display display = new Display();
     final Shell shell = new Shell( display, RWT.NONE );
     shell.setBounds( 10, 10, 800, 600 );
   
     ToolBar toolBar = new ToolBar( shell, RWT.NONE );
     ToolItem item1 = new ToolItem( toolBar, RWT.PUSH );
   
     ...
   
     shell.layout();
     shell.open();
     return display;
   }
 }
</pre>
<p></code>
</p>
<a name="Naming_Your_Application"></a><h3>Naming Your Application</h3>
<p>Not yet implemented. The HTML title could be used to mimic a minimal application naming.
</p>
<a name="Display_Life_Cycle"></a><h3>Display Life Cycle</h3>
<p>Similar, but the display lives as long as the browser session is active.
</p>
<a name="Events_and_Listeners"></a><h3>Events and Listeners</h3>
<p>Will be implemented.
</p>
<a name="Event_Filters"></a><h3>Event Filters</h3>
<p>Not yet implemented. Quote SWT book: "Filters are Powerful and Dangerous".
One of the standard use cases for event filtering - large numbers of events - are not a good idea for RWT because of the distributed nature of RAP (and associated network latency).
</p>
<a name="Runnable_.22Execs.22"></a><h3>Runnable "Execs"</h3>
<p>Not yet implemented. 
</p>
<a name="The_Event_Loop"></a><h3>The Event Loop</h3>
<p>Not applicable. We have request / response cycles instead. Please see also the thread topic directly below.
</p>
<a name="Multithreaded_Programming"></a><h3>Multithreaded Programming</h3>
<p>Not yet implemented. The UI thread will be represented by the thread that services the browser (ajax) request.
</p><p>Asynchonous execution requires some effort on the RWT side, as the client needs to be informed of UI changes. As http is a stateless protocol with request/response pushing of data is not intended by the creators of the protocol. There are two workarounds:
</p>
<ul><li> Polling (the client polls the server regulary while an async exec is running)
</li><li> so called Comet - a http response is kept open / alive and can be used to push data to the browser. Latest developments in java servers promise to implement Comet with minimal overhead (Jetty, Glassfish).
</li></ul>
<p>Threading requires extra care as we are executing them on a server!
</p>
<a name="Timers"></a><h3>Timers</h3>
<p>Not yet implemented.
</p>
<a name="Putting_It_All_Together:_Multithreading.2C_Timers.2C_Events.2C_and_the_Event_Loop"></a><h3>Putting It All Together: Multithreading, Timers, Events, and the Event Loop</h3>
<ul><li> Events are generated by the user and read and dispatched to widgets by the the thread that services the request.
</li><li> Application code registers interest in events by adding event listeners to widgets. ...
</li><li> If the user interface thread is busy (in our case a request has not received its response) further events are queued (on the client side).
</li><li> pushing UI updates to the user by calling a method like readAndDispatch() is not possible
</li><li> no timers yet&nbsp;;-)
</li></ul>
<a name="Monitors.2C_Bounds.2C_and_Client_Area"></a><h3>Monitors, Bounds, and Client Area</h3>
<ul><li> Very likely no Monitors ...
</li><li> Bounds / Client Area - implemented as the size of the browser window
</li></ul>
<a name="The_Active_Shell.2C_All_Shells.2C_and_Focus_Control"></a><h3>The Active Shell, All Shells, and Focus Control</h3>
<p>Not yet implemented
</p>
<a name="Cursor_Control_and_Location"></a><h3>Cursor Control and Location</h3>
<p>Very unlikely to be implemented.
</p>
<a name="Display_Depth_and_DPI"></a><h3>Display Depth and DPI</h3>
<p>Sorry, but no;-)
</p>
<a name="Updating_the_Display"></a><h3>Updating the Display</h3>
<p>Updating the Display is not an issue in RWT. At the end of the request life cycle all changes are 'rendered' and sent to the client.
</p>
<a name="Application_Data"></a><h3>Application Data</h3>
<p>Not yet implemented, but will work as in SWT.
</p>
<a name="Coordinate_Mapping_and_Mirroring"></a><h3>Coordinate Mapping and Mirroring</h3>
<p>Not yet fully implemented, but will work as in SWT.
Please note that to fully support bidirectional languages there has more to be done than mirroring and it is yet unclear if we can realize this client-side.
</p>
<a name="Miscellaneous"></a><h3>Miscellaneous</h3>
<ul><li> Beep: no&nbsp;:(
</li><li> Double-Click Time: depends on the JavaScript library (<a href="http://qooxdoo.org" class='external free' title="http://qooxdoo.org" rel="nofollow">http://qooxdoo.org</a>) we are using on the client side.
</li></ul>